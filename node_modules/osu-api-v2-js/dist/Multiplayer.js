import { getId } from "./misc.js";
export var Multiplayer;
(function (Multiplayer) {
    let Room;
    (function (Room) {
        let PlaylistItem;
        (function (PlaylistItem) {
            /**
             * Get the scores on a specific item of a room!
             * @param item An object with the id of the item in question, as well as the id of the room
             * @param limit How many scores maximum? Defaults to 50, the maximum the API will return
             * @param sort Sort by scores, ascending or descending? Defaults to descending
             * @param cursor_string Use a Multiplayer.Scores' `params` and `cursor_string` to get the next page (scores 51 to 100 for example)
             * @remarks This will **not work for rooms created before ~March 5th 2024** https://github.com/ppy/osu-web/issues/10725
             */
            async function getScores(item, limit = 50, sort = "score_desc", cursor_string) {
                return await this.request("get", `rooms/${item.room_id}/playlist/${item.id}/scores`, { limit, sort, cursor_string });
            }
            PlaylistItem.getScores = getScores;
        })(PlaylistItem = Room.PlaylistItem || (Room.PlaylistItem = {}));
        let Leader;
        (function (Leader) {
            /**
             * Get the room stats of all the users of that room!
             * @scope {@link Scope"public"}
             * @param room The room or the id of the room in question
             * @returns An object with the leaderboard, and the score and position of the authorized user under `user_score`
             */
            async function getMultiple(room) {
                return await this.request("get", `rooms/${getId(room)}/leaderboard`);
            }
            Leader.getMultiple = getMultiple;
        })(Leader = Room.Leader || (Room.Leader = {}));
        /**
         * Get data about a lazer multiplayer room (realtime or playlists)!
         * @param room The room or the id of the room, can be found at the end of its URL (after `/multiplayer/rooms/`)
         */
        async function getOne(room) {
            return await this.request("get", `rooms/${getId(room)}`);
        }
        Room.getOne = getOne;
        /**
         * Get playlists/realtime rooms that are active, that have ended, that the user participated in, that the user made, or just simply any room!
         * @scope {@link Scope"public"}
         * @param type Whether the multiplayer rooms are in playlist format (like current spotlights) or realtime
         * @param mode The state of the room, or the relation of the authorized user with the room
         * @param limit The maximum amount of rooms to return, defaults to 10
         * @param sort Sort (where most recent is first) by creation date or end date, defaults to the creation date
         * @param season_id Only get rooms (playlists) that belong to a specific (modern) *Beatmap Spotlights* season **id**
         * (so `5`'d be summer 2020's mania rooms, not winter 2022!!)
         */
        async function getMultiple(type, mode, limit = 10, sort = "created", season_id) {
            return await this.request("get", "rooms", { type_group: type, mode, limit, sort, season_id });
        }
        Room.getMultiple = getMultiple;
    })(Room = Multiplayer.Room || (Multiplayer.Room = {}));
    let Match;
    (function (Match) {
        /**
         * Get data of a multiplayer lobby from the stable (non-lazer) client that have URLs with `community/matches` or `mp`
         * @param match The id of a match can be found at the end of its URL
         * @param query Filter and limit the amount of events shown
         */
        async function getOne(match, query) {
            const response = await this.request("get", `matches/${getId(match)}`, {
                before: query?.before ? getId(query.before) : undefined,
                after: query?.after ? getId(query.after) : undefined,
                limit: query?.limit
            });
            // This converts scores' "perfect" from number to boolean
            for (let i = 0; i < response.events.length; i++) {
                for (let e = 0; e < Number(response.events[i].game?.scores.length); e++) {
                    response.events[i].game.scores[e].perfect = Boolean(response.events[i].game.scores[e].perfect);
                }
            }
            return response;
        }
        Match.getOne = getOne;
        /**
         * Get the info about several matches!
         * @param query The id of the first match of the array, and the sorting and size of said array
         */
        async function getMultiple(query) {
            // `first_match_in_array` is a cool way to use the endpoint's cursor
            const cursor = query?.first_match_in_array ? { match_id: getId(query.first_match_in_array) + (query?.sort === "id_asc" ? -1 : 1) } : undefined;
            const response = await this.request("get", "matches", { cursor, limit: query?.limit, sort: query?.sort });
            return response.matches; // NOT the only property; `params` is useless while `cursor` and `cursor_string` are superseded by `first_match_in_array`
        }
        Match.getMultiple = getMultiple;
    })(Match = Multiplayer.Match || (Multiplayer.Match = {}));
})(Multiplayer || (Multiplayer = {}));
